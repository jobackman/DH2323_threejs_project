<!DOCTYPE html>
<html>
	<head>
		<style> body {margin: 0px;}</style>
	</head>

	<body> 
		<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script>
		
			//----------------------------------------------------------
			// GLOBAL VARIABLES
			var planeWidth = 1000;
			var planeHeight = 600;
			var zombies = 25;
			var zombieSpeed = 0.5; 
			var humans = 1;
			var humanSpeed = 1.5;
			var flock = [];
			var people = [];
			
			var align;
			var alignx;
			var aligny;
			var cohesion;
			var cohesionx;
			var cohesiony;
			
			var fov = Math.PI * 0.5;
			
			//----------------------------------------------------------
			// INITIALIZE
			
			// renderer
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			
			// camera
			var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.y = -planeHeight - 100;
			camera.position.z = planeHeight + 100;
			camera.rotation.x = 45 * (Math.PI / 180);
			
			// scene
			var scene = new THREE.Scene();

			// GRID
			var numW = planeWidth/100; // how many wide
			var numH = planeHeight/100; // how many tall
			var plane = new THREE.Mesh( new THREE.PlaneGeometry( planeWidth, planeHeight, numW, numH ), new   THREE.MeshBasicMaterial( { color: 0x303030, wireframe: true } ) );
			scene.add(plane);
		
/*
			var grid = new THREE.GridHelper(planeHeight, 100);
			grid.rotation.x = 90*Math.PI/180;
			scene.add(grid);
*/	
			
			// -------------------------------------------------------------------------------------
			//Spawn ZOMBIES
			for( i = 0; i < zombies; i++ ){
			
				var zombie = new THREE.Mesh( new THREE.CylinderGeometry( 0, 15, 15, 12 ), new THREE.MeshBasicMaterial( {color: 0xff0000, wireframe: true}) );		
				zombie.position.x = Math.floor(Math.random() * planeWidth) - planeWidth / 2;
				zombie.position.y = Math.floor(Math.random() * planeHeight) - planeHeight / 2;
				zombie.dx = Math.random() - 0.5;
				zombie.dy = Math.random() - 0.5;
				var len = Math.sqrt(zombie.dx*zombie.dx + zombie.dy*zombie.dy);
				zombie.dx /= len;
				zombie.dy /= len;
				//zombie.rotation.z = Math.atan2(zombie.dx, zombie.dy);
	
				flock.push(zombie);				
				scene.add(zombie);
			}
			
			// -------------------------------------------------------------------------------------
			//Spawn PEOPLE
			for( i = 0; i < humans; i++ ){
				var human = new THREE.Mesh( new THREE.CylinderGeometry( 0, 15, 15, 12 ), new THREE.MeshBasicMaterial( {color: 0xffff00, wireframe: true}) );		
				human.position.x = Math.floor(Math.random() * planeWidth) - planeWidth / 2;
				human.position.y = Math.floor(Math.random() * planeHeight) - planeHeight / 2;
				human.dx = Math.random() - 0.5;
				human.dy = Math.random() - 0.5;
				var len = Math.sqrt(human.dx*human.dx + human.dy*human.dy);
				human.dx /= len;
				human.dy /= len;
				human.rotation.z = Math.atan2(human.dx, human.dy);
				
				people.push(human);
				scene.add(human);
			}

			
			// Add OrbitControls so that we can pan around with the mouse.
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			
			// START THE ANIMATION
			render();
			
			
			// -------------------------------------------------------------------------------------
			// -------------------------------------------------------------------------------------
			// FUNCTIONS
		
			// What happens each render
			function render(){	 	
							
				// render
				renderer.render(scene, camera);				
				controls.update();
				
				updateFlock();
								
				// request new frame
				requestAnimationFrame(function(){
				    render();
				});
			}
			
			
			function updateFlock(){
			
				// -------------------------------------------------------------------------------
				// HUMAN MOVEMENT
				for(i = 0; i < people.length; i++){
					human = people[i];
					
					var encounter = 0; 
					var sepx = 0;
					var sepy = 0;
					
					for (j = 0; j < flock.length; j++){	
						var zombie = flock[j];
						
						// -----------------------------------------------------------------------
						// Jämför distance med alla andra zombies
						var diffX = zombie.position.x - human.position.x ;
						var diffY = zombie.position.y - human.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);				
						
						// If caught
						if(distance <= 20){
							console.log("Get caught n00b!");
						}
						
						// Separate from zombies
						if (distance <= 100){
							sepx += diffX;
							sepy += diffY; 
							encounter += 1;
						}	
										
					}
					
					// ------------------------------------------------------------------------------
					// TODO: Funker ej som det borde, för buggat. 
					if(encounter){	
					
						// Vector towards the center
						var avgdx = -(sepx / encounter);
						var avgdy = -(sepy / encounter);		
						dist = Math.sqrt(avgdx * avgdx + avgdy * avgdy);
						
						human.dx = human.dx * 0.8 + avgdx/dist * 0.2;
						human.dy = human.dy * 0.8 + avgdy/dist * 0.2;
						
/*
						// Normalize to Length = 1
						var dxdyLen = Math.sqrt(human.dx*human.dx + human.dy*human.dy);
						human.dx /= dxdyLen;
						human.dy /= dxdyLen;	
*/		
					}				
					
					// ------------------------------------------------------------------------------
					// If close to wall, make sure to turn
/*
					var leftwall = human.position.x + human.dx + planeWidth/2;
					var rightwall = human.position.x + human.dx - planeWidth/2;
					var lowerwall = human.position.y + human.dy + planeHeight/2;
					var upperwall = human.position.y + human.dy - planeHeight/2;
					
					if (leftwall < 20) human.dx = human.dx*0.6 + (-human.dx)/(Math.sqrt(leftwall*lefwall))*0.4;		//Left
					if (rightwall > -20) human.dx = human.dx*0.6 + (-human.dx)/(Math.sqrt(rightwall*rightwall))*0.4;//Right
					if (lowerwall < 20) human.dy = human.dx*0.6 + (-human.dx)/(Math.sqrt(lowerwall*lowerwall))* 0.4;//Lower
					if (upperwall > -20) human.dy = human.dx*0.6 + (-human.dx)/(Math.sqrt(upperwall*upperwall))* 0.4;//Upper
*/
					
					// ------------------------------------------------------------------------------
					// Make sure not to leave grid
					if ((human.position.x + human.dx) < -planeWidth/2) human.dx = -human.dx;			//Left
					if ((human.position.x + human.dx) > planeWidth/2) human.dx = -human.dx;				//Right
					if ((human.position.y + human.dy) < -planeHeight/2) human.dy = -human.dy;			//Lower
					if ((human.position.y + human.dy) > planeHeight/2) human.dy = -human.dy;			//Upper
					
					// Normalize to Length = 1
					var dxdyLen = Math.sqrt(human.dx*human.dx + human.dy*human.dy);
					human.dx /= dxdyLen;
					human.dy /= dxdyLen;
					
					// Update position & rotation
					human.position.x += human.dx * humanSpeed;
					human.position.y += human.dy * humanSpeed;	
					human.rotation.z = Math.atan2(human.dx, human.dy) - Math.PI / 2; // TODO: Rotation not working correctly
				}
				
				
				// -------------------------------------------------------------
				// ZOMBIE MOVEMENT
				for(i = 0; i < flock.length; i++){
					zombie = flock[i];
					
					align = false;
					alignx = 0;
					aligny = 0;
					ac = 0;
					cohesion = false;
					cohesionx = 0;
					cohesiony = 0;
					cc = 0;
					
					for (j = 0; j < people.length; j++){	
						
						var human = people[j];
						
						// ---------------------------------------------
						//TODO: Jämför distance med alla humans
						
						var diffX = zombie.position.x - human.position.x;
						var diffY = zombie.position.y - human.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);
						
						var diffAngle = zombie.rotation.z - human.rotation.z;
						if (diffAngle > Math.PI) diffAngle = 2 * Math.PI - diffAngle;
						if (diffAngle < -Math.PI) diffAngle = -2 * Math.PI + diffAngle;
			
						var seen = Math.abs(diffAngle) <= fov;
	
						// Chase if spotted
						 if (distance <= 150){
							if(!seen) continue;
							cohesionx += human.position.x;
							cohesiony += human.position.y;
							cohesion = true;
							cc += 1;
						}		
					}
					
					for (k = 0; k < flock.length; k++){	
						if(i == k) continue;

						var otherZombie = flock[k];
						
						// ---------------------------------------------
						//TODO: Jämför distance med alla andra zombies
						
						var diffX = zombie.position.x - otherZombie.position.x;
						var diffY = zombie.position.y - otherZombie.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);
						
						var diffAngle = zombie.rotation.z - otherZombie.rotation.z;
						if (diffAngle > Math.PI) diffAngle = 2 * Math.PI - diffAngle;
						if (diffAngle < -Math.PI) diffAngle = -2 * Math.PI + diffAngle;
			
						var seen = Math.abs(diffAngle) <= fov;
	
						
						// Separate
						if (distance <= 25){
							zombie.dx = zombie.dx * 0.8 + diffX / distance * 0.2;
							zombie.dy = zombie.dy * 0.8 + diffY / distance * 0.2; 
						}
						// Align speed
						else if (distance <= 50){
							if(!seen) continue;
							alignx += otherZombie.dx;
							aligny += otherZombie.dy;
							align = true;
							ac += 1;
						}
						// Cohesion
						else if (distance <= 90){
							if(!seen) continue;
							continue; 								// TODO: Ska de grupperas på avstånd? 
							cohesionx += otherZombie.position.x;
							cohesiony += otherZombie.position.y;
							cohesion = true;
							cc += 1;
						}
						
						// ---------------------------------------------			
					}
					
					if(align){
						avgdx = alignx / ac;
						avgdy = aligny / ac;
						dist = Math.sqrt(avgdx*avgdx + avgdy*avgdy);
						
						zombie.dx = zombie.dx * 0.95 + avgdx / dist * 0.05;
						zombie.dy = zombie.dy * 0.95 + avgdy / dist * 0.05;	

						// Normalize
						dxdyLen = Math.sqrt(zombie.dx*zombie.dx + zombie.dy*zombie.dy);
						zombie.dx /= dxdyLen;
						zombie.dy /= dxdyLen;
					}
					
					if(cohesion){
						// Center coordinates of the crowd
						cohesionx = cohesionx / cc;
						cohesiony = cohesiony / cc;
						
						// Vector towards the center
						avgdx = cohesionx - zombie.position.x;
						avgdy = cohesiony - zombie.position.y;		
						dist = Math.sqrt(avgdx * avgdx + avgdy * avgdy);
						
						zombie.dx = zombie.dx * 0.9 + avgdx / dist * 0.1;
						zombie.dy = zombie.dy * 0.9 + avgdy / dist * 0.1;	
						
						// Normalize
						dxdyLen = Math.sqrt(zombie.dx*zombie.dx + zombie.dy*zombie.dy);
						zombie.dx /= dxdyLen;
						zombie.dy /= dxdyLen;
					}
	
					
					// ---------------------------------------------
					// Update position on zombie
					if ((zombie.position.x + zombie.dx) < -planeWidth/2) zombie.dx = -zombie.dx;
					if ((zombie.position.y + zombie.dy) < -planeHeight/2) zombie.dy = -zombie.dy;
					if ((zombie.position.x + zombie.dx) > planeWidth/2) zombie.dx = -zombie.dx;
					if ((zombie.position.y + zombie.dy) > planeHeight/2) zombie.dy = -zombie.dy;
					
					zombie.position.x += zombie.dx * zombieSpeed;
					zombie.position.y += zombie.dy * zombieSpeed;	
					//zombie.rotation.z = Math.atan2(zombie.dx, zombie.dy);
					
				}
				
			}
			
		</script>
	</body>
</html>