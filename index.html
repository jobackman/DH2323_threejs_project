<!DOCTYPE html>
<html>
	<head>
		<style> body {margin: 0px;}</style>
	</head>

	<body> 
		<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script>
		
			//----------------------------------------------------------
			// GLOBAL VARIABLES
			var planeWidth = 1000;
			var planeHeight = 600;
			var zombies = 25;
			var zombieSpeed = 0.5; 
			var humans = 2;
			var humanSpeed = 2;
			var flock = [];
			var people = [];
			
			var align;
			var alignx;
			var aligny;
			var cohesion;
			var cohesionx;
			var cohesiony;
			
			var fov = Math.PI * 0.5;
			
			//----------------------------------------------------------
			// INITIALIZE
			
			// renderer
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			
			// camera
			var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
			camera.position.y = -planeHeight - 100;
			camera.position.z = planeHeight + 100;
			camera.rotation.x = 45 * (Math.PI / 180);
			
			// scene
			var scene = new THREE.Scene();

			// GRID
			var numW = planeWidth/100; // how many wide
			var numH = planeHeight/100; // how many tall
			var plane = new THREE.Mesh( new THREE.PlaneGeometry( planeWidth, planeHeight, numW, numH ), new   THREE.MeshBasicMaterial( { color: 0x303030, wireframe: true } ) );
			scene.add(plane);		
			
			//Spawn ZOMBIES
			for( i = 0; i < zombies; i++ ){
			
				var zombie = new THREE.Mesh( new THREE.CylinderGeometry( 0, 15, 15, 12 ), new THREE.MeshBasicMaterial( {color: 0xff0000, wireframe: true}) );		
				zombie.position.x = Math.floor(Math.random() * planeWidth) - planeWidth / 2;
				zombie.position.y = Math.floor(Math.random() * planeHeight) - planeHeight / 2;
				zombie.dx = Math.random() - 0.5;
				zombie.dy = Math.random() - 0.5;
				zombie.rotation.z = Math.atan2(zombie.dx, zombie.dy);
	
				flock.push(zombie);				
				scene.add(zombie);
			}
			
			//Spawn PEOPLE
			for( i = 0; i < humans; i++ ){
				var human = new THREE.Mesh( new THREE.CylinderGeometry( 0, 15, 15, 12 ), new THREE.MeshBasicMaterial( {color: 0xffff00, wireframe: true}) );		
				human.position.x = Math.floor(Math.random() * planeWidth) - planeWidth / 2;
				human.position.y = Math.floor(Math.random() * planeHeight) - planeHeight / 2;
				human.dx = Math.random() - 0.5;
				human.dy = Math.random() - 0.5;
				human.rotation.z = Math.atan2(human.dx, human.dy);
				
				people.push(human);
				scene.add(human);
			}

			
			// Add OrbitControls so that we can pan around with the mouse.
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			
			// START THE ANIMATION
			render();
			
			
			// ----------------------------------------------------------------------
			// FUNCTIONS
		
			// What happens each render
			function render(){	 	
							
				// render
				renderer.render(scene, camera);				
				controls.update();
				
				updateFlock();
								
				// request new frame
				requestAnimationFrame(function(){
				    render();
				});
			}
			
			
			function updateFlock(){
			
				// -------------------------------------------------------------------
				// HUMAN MOVEMENT
				for(i = 0; i < people.length; i++){
					human = people[i];
					
					var encounter = 0; 
					var sepx = 0;
					var sepy = 0;
					var avgdx = 0;
					var avgdy = 0;
					
					for (j = 0; j < flock.length; j++){	
						
						var otherZombie = flock[j];
						
						// ---------------------------------------------
						// Jämför distance med alla andra zombies
						
						var diffX = human.position.x - otherZombie.position.x;
						var diffY = human.position.y - otherZombie.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);				
						
						// If caught
						if(distance <= 20){
							console.log("Get caught n00b!");
						}
						
						// Separate
						else if (distance <= 80){
							sepx += diffX / distance;
							sepy += diffY / distance; 
							encounter += 1;
						}					
					}
					
					// TODO: Funker ej som det borde, för buggat. 
					if(encounter){	
						// Vector towards the center
						avgdx = sepx - human.position.x;
						avgdy = sepy - human.position.y;		
						dist = Math.sqrt(avgdx * avgdx + avgdy * avgdy);
						
						human.dx = human.dx * 0.5 + sepy * 0.5;
						human.dy = human.dy * 0.5 + sepy * 0.5;
					}				
					
					// ---------------------------------------------
					// Update position on human
					if ((human.position.x + human.dx) < -planeWidth/2) human.dx = -human.dx;
					if ((human.position.y + human.dy) < -planeHeight/2) human.dy = -human.dy;
					if ((human.position.x + human.dx) > planeWidth/2) human.dx = -human.dx;
					if ((human.position.y + human.dy) > planeHeight/2) human.dy = -human.dy;
			
					human.position.x += human.dx * humanSpeed;
					human.position.y += human.dy * humanSpeed;	
					human.rotation.z = Math.atan2(human.dx, human.dy);
				}
				
				
				// -------------------------------------------------------------
				// ZOMBIE MOVEMENT
				for(i = 0; i < flock.length; i++){
					zombie = flock[i];
					
					align = false;
					alignx = 0;
					aligny = 0;
					ac = 0;
					cohesion = false;
					cohesionx = 0;
					cohesiony = 0;
					cc = 0;
					
					for (j = 0; j < people.length; j++){	
						
						var otherZombie = people[j];
						
						// ---------------------------------------------
						//TODO: Jämför distance med alla andra zombies
						
						var diffX = zombie.position.x - otherZombie.position.x;
						var diffY = zombie.position.y - otherZombie.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);
						
						var diffAngle = zombie.rotation.z - otherZombie.rotation.z;
						if (diffAngle > Math.PI) diffAngle = 2 * Math.PI - diffAngle;
						if (diffAngle < -Math.PI) diffAngle = -2 * Math.PI + diffAngle;
			
						var seen = Math.abs(diffAngle) <= fov;
	
						// Align speed
						if (distance <= 50){
							if(!seen) continue;
							alignx += otherZombie.dx;
							aligny += otherZombie.dy;
							align = true;
							ac += 1;
						}
						// Cohesion
						else if (distance <= 100){
							if(!seen) continue;
							cohesionx += otherZombie.position.x;
							cohesiony += otherZombie.position.y;
							cohesion = true;
							cc += 1;
						}
						// ---------------------------------------------			
					}
					
					for (k = 0; k < flock.length; k++){	
						if(i == k) continue;
						
						var otherZombie = flock[k];
						
						// ---------------------------------------------
						//TODO: Jämför distance med alla andra zombies
						
						var diffX = zombie.position.x - otherZombie.position.x;
						var diffY = zombie.position.y - otherZombie.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);
						
						var diffAngle = zombie.rotation.z - otherZombie.rotation.z;
						if (diffAngle > Math.PI) diffAngle = 2 * Math.PI - diffAngle;
						if (diffAngle < -Math.PI) diffAngle = -2 * Math.PI + diffAngle;
			
						var seen = Math.abs(diffAngle) <= fov;
	
						
						// Separate
						if (distance <= 20){
							zombie.dx = diffX / distance;
							zombie.dy = diffY / distance; 
						}
						// Align speed
						if (distance <= 40){
							if(!seen) continue;
							alignx += otherZombie.dx;
							aligny += otherZombie.dy;
							align = true;
							ac += 1;
						}
						// Cohesion
						else if (distance <= 70){
							if(!seen) continue;
							cohesionx += otherZombie.position.x;
							cohesiony += otherZombie.position.y;
							cohesion = true;
							cc += 1;
						}
						
						// ---------------------------------------------			
					}
					
					if(align){
						avgdx = alignx / ac;
						avgdy = aligny / ac;
						
						dist = Math.sqrt(avgdx*avgdx + avgdy*avgdy);
						
						zombie.dx = (zombie.dx + avgdx / dist) / 2;
						zombie.dy = (zombie.dy + avgdy / dist) / 2;	
					}
					
					if(cohesion){
						// Center coordinates of the crowd
						cohesionx = cohesionx / cc;
						cohesiony = cohesiony / cc;
						
						// Vector towards the center
						avgdx = cohesionx - zombie.position.x;
						avgdy = cohesiony - zombie.position.y;		
						dist = Math.sqrt(avgdx * avgdx + avgdy * avgdy);
						
						zombie.dx = zombie.dx * 0.3 + avgdx / dist * 0.7;
						zombie.dy = zombie.dy * 0.3 + avgdy / dist * 0.7;	
					}
	
					
					// ---------------------------------------------
					// Update position on zombie
					if ((zombie.position.x + zombie.dx) < -planeWidth/2) zombie.dx = -zombie.dx;
					if ((zombie.position.y + zombie.dy) < -planeHeight/2) zombie.dy = -zombie.dy;
					if ((zombie.position.x + zombie.dx) > planeWidth/2) zombie.dx = -zombie.dx;
					if ((zombie.position.y + zombie.dy) > planeHeight/2) zombie.dy = -zombie.dy;
			
					zombie.position.x += zombie.dx * zombieSpeed;
					zombie.position.y += zombie.dy * zombieSpeed;	
					zombie.rotation.z = Math.atan2(zombie.dx, zombie.dy);
				}
				
			}
			
		</script>
	</body>
</html>