<!DOCTYPE html>
<html>
	<head>
		<style> </style>
	</head>

	<body> 
			<!-- Latest compiled and minified CSS -->
		<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
		<link rel="stylesheet" href="css/style.css">
		<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script>
		
			//----------------------------------------------------------
			// GLOBAL VARIABLES
			var planeWidth = 1000;
			var planeHeight = 600;
			var zombies = 15;
			var zombieSpeed = 0.2; 
			var humans = 3;
			var humanSpeed = 1.5;
			var flock = [];
			var people = [];
			var cubes = [];		
			var numCubes = 15;	
			var align;
			var alignx;
			var aligny;
			var cohesion;
			var cohesionx;
			var cohesiony;
						
			var fov = 120 * Math.PI / 180;
			
			//----------------------------------------------------------
			// INITIALIZE
			
			// clock for animations
			var clock = new THREE.Clock();
			
			// renderer
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			
			// camera
			var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
			camera.position.y = -planeHeight - 100;
			camera.position.z = planeHeight + 100;
			camera.rotation.x = 45 * (Math.PI / 180);
			
			// OrbitControls so that we can pan around with the mouse.
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			
			// scene
			var scene = new THREE.Scene();

			// GRID
			var numW = planeWidth/50; // how many wide
			var numH = planeHeight/50; // how many tall
			var plane = new THREE.Mesh( new THREE.PlaneGeometry( planeWidth, planeHeight, numW, numH ), new   THREE.MeshBasicMaterial( { color: 0x303030, wireframe: true } ) );
			scene.add(plane);
			
			// CUBES
/*
			var geometry = new THREE.BoxGeometry( 50, 50, 50 );
			var material = new THREE.MeshLambertMaterial( { color: 0xffffff, shading: THREE.FlatShading, overdraw: 0.5 } );

			for ( var i = 0; i < numCubes; i ++ ) {
				var cube = new THREE.Mesh( geometry, material );

				cube.scale.z = Math.floor( Math.random() * 2 + 1 );

				cube.position.x = Math.floor( ( Math.random() * planeWidth - planeWidth/2) / 50 ) * 50 + 25;
				cube.position.z = cube.scale.z * 50 / 2;
				cube.position.y = Math.floor( ( Math.random() * planeHeight -planeHeight/2) / 50 ) * 50 + 25;
				
				cubes.push(cube);
				scene.add(cube);
			}
*/
			
			// LIGHTS
			var ambientLight = new THREE.AmbientLight( 1 * 0x10 );
			scene.add( ambientLight );

			var directionalLight = new THREE.DirectionalLight( 0.7 * 0xffffff );
			directionalLight.position.x = Math.random() - 0.5;
			directionalLight.position.y = Math.random() - 0.5;
			directionalLight.position.z = Math.random();
			directionalLight.position.normalize();
			scene.add( directionalLight );

			var directionalLight = new THREE.DirectionalLight( 0.7 * 0xffffff );
			directionalLight.position.x = Math.random() - 0.5;
			directionalLight.position.y = Math.random() - 0.5;
			directionalLight.position.z = Math.random() - 0.5;
			directionalLight.position.normalize();
			scene.add( directionalLight );
				
				
			// -------------------------------------------------------------------------------------
			//Spawn ZOMBIES & People
			for( i = 0; i < zombies; i++ ) spawnZombie();
			for( i = 0; i < humans; i++ ) spawnHuman();			
			
			// START THE ANIMATION
			render();
			
			
			// -------------------------------------------------------------------------------------
			// -------------------------------------------------------------------------------------
			// FUNCTIONS
			
			// Main rendering function
			function render(){	 	
							
				// render
				renderer.render(scene, camera);				
				controls.update();
				
				updateFlock();
				
				// update model animations
				var delta = clock.getDelta();
				
				for ( var i = 0; i < flock.length; i ++ ) {
					var zombie = flock[ i ];
					zombie.updateAnimation( 1000 * delta );
				}
								
				// request new frame
				requestAnimationFrame(function(){
				    render();
				});
			}
			
			// -------------------------------------------------------------
			// Add Zombies

			function spawnZombie(){
/*
				var zombie = new THREE.Mesh( new THREE.CylinderGeometry( 0, 15, 15, 12 ), new THREE.MeshBasicMaterial( {color: 0xff0000, wireframe: true}) );		
				
				zombie.position.x = Math.floor(Math.random() * planeWidth) - planeWidth / 2;
				zombie.position.y = Math.floor(Math.random() * planeHeight) - planeHeight / 2;
				zombie.dx = Math.random() - 0.5;
				zombie.dy = Math.random() - 0.5;
				var len = Math.sqrt(zombie.dx*zombie.dx + zombie.dy*zombie.dy);
				zombie.dx /= len;
				zombie.dy /= len;
				zombie.rotation.z = Math.atan2(zombie.dy, zombie.dx);
	
				flock.push(zombie);				
				scene.add(zombie);
*/
					
			var loader = new THREE.JSONLoader();
				loader.load( "untitled.js", function( geometry ) {

					geometry.computeMorphNormals();

					var material = new THREE.MeshPhongMaterial( { color: 0xfff0000,  shininess: 17,  morphTargets: true, morphNormals: true, vertexColors: THREE.NoColors, shading: THREE.FlatShading } );
					var zombie = new THREE.MorphAnimMesh( geometry, material );

					zombie.duration = 3000;
					//zombie.userData.delta = -13;
					
					zombie.scale.set(70,70,70);
					
					zombie.position.x = Math.floor(Math.random() * planeWidth) - planeWidth / 2;
					zombie.position.y = Math.floor(Math.random() * planeHeight) - planeHeight / 2;
					zombie.dx = Math.random() - 0.5;
					zombie.dy = Math.random() - 0.5;
					var len = Math.sqrt(zombie.dx*zombie.dx + zombie.dy*zombie.dy);
					zombie.dx /= len;
					zombie.dy /= len;
					
					zombie.rotation.x = 90 * Math.PI / 180;
					zombie.rotation.y = Math.atan2(zombie.dy, zombie.dx) + Math.PI;

					scene.add( zombie );
					flock.push( zombie );

			
				});
				
			}
			
			// --------------------------------------------------------------
			// Add Human
			function spawnHuman(){
				var human = new THREE.Mesh( new THREE.CylinderGeometry( 0, 15, 15, 12 ), new THREE.MeshBasicMaterial( {color: 0xffff00, wireframe: true}) );		
				human.position.x = Math.floor(Math.random() * planeWidth) - planeWidth / 2;
				human.position.y = Math.floor(Math.random() * planeHeight) - planeHeight / 2;
				human.dx = Math.random() - 0.5;
				human.dy = Math.random() - 0.5;
				var len = Math.sqrt(human.dx*human.dx + human.dy*human.dy);
				human.dx /= len;
				human.dy /= len;
				human.bitten = 0;
				human.rotation.z = Math.atan2(human.dy, human.dx);
				
				people.push(human);
				scene.add(human);
			}
			
			
			function updateFlock(){
				// ----------------------------------------------------------------------------------
				// HUMAN MOVEMENT
				for(i = 0; i < people.length; i++){
					human = people[i];
					
					var encounter = 0; 
					var sepx = 0;
					var sepy = 0;
					var runspeed = 1;
					
					// ------------------------------------------------------------------------------
					// Jämför med ALLA zombies
					for (j = 0; j < flock.length; j++){	
						var zombie = flock[j];
						
						var diffX = zombie.position.x - human.position.x ;
						var diffY = zombie.position.y - human.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);				
						
						// If caught
						if(distance <= 20 ){
							human.bitten += 1;
							if(human.bitten >= 100){
								// Turn to zombie								
							}
						}
						
						// Separate from zombies
						else if (distance <= 100){
							sepx += diffX;
							sepy += diffY; 
							encounter += 1;
						}						
					}
					
					// ------------------------------------------------------------------------------
					// Separate from zombies 
					if(encounter){	

						// Vector towards the center
						var avgdx = -(sepx / encounter);
						var avgdy = -(sepy / encounter);		
						dist = Math.sqrt(avgdx * avgdx + avgdy * avgdy);
						human.dx = human.dx * 0.8 + avgdx/dist * 0.2;
						human.dy = human.dy * 0.8 + avgdy/dist * 0.2;
						
						runspeed = 1.5;
					}				
					
					// ------------------------------------------------------------------------------
					// TODO: Jämför alla hus

					
					// ------------------------------------------------------------------------------
					// If close to wall, make sure to turn
					var leftwall = human.position.x + human.dx + planeWidth/2;
					var rightwall = human.position.x + human.dx - planeWidth/2;
					var lowerwall = human.position.y + human.dy + planeHeight/2;
					var upperwall = human.position.y + human.dy - planeHeight/2;
					
					// Keep an eye on far wall if zombie-encounter
					if(encounter){
						if (leftwall < 80) human.dx = human.dx * 0.9 + (0.5) * 0.1;			//Left
						if (rightwall > -80) human.dx = human.dx * 0.9 + (-0.5) * 0.1;		//Right
						if (lowerwall < 80) human.dy = human.dy * 0.9 + (0.5) * 0.1;		//Lower
						if (upperwall > -80) human.dy = human.dy * 0.9 + (-0.5) * 0.1;		//Upper
					}
					
					if (leftwall < 40) human.dx = human.dx * 0.9 + (1) * 0.1;				//Left
					if (rightwall > -40) human.dx = human.dx * 0.9 + (-1) * 0.1;			//Right
					if (lowerwall < 40) human.dy = human.dy * 0.9 + (1) * 0.1;				//Lower
					if (upperwall > -40) human.dy = human.dy * 0.9 + (-1) * 0.1;			//Upper
					
					// Make sure not to leave grid
					if ((human.position.x + human.dx) < -planeWidth/2) human.dx = -human.dx;			//Left
					if ((human.position.x + human.dx) > planeWidth/2) human.dx = -human.dx;				//Right
					if ((human.position.y + human.dy) < -planeHeight/2) human.dy = -human.dy;			//Lower
					if ((human.position.y + human.dy) > planeHeight/2) human.dy = -human.dy;			//Upper
					
					// ------------------------------------------------------------------------------
					// Normalize to Length = 1
					var len = Math.sqrt(human.dx*human.dx + human.dy*human.dy);
					human.dx /= len;
					human.dy /= len;
					
					// Update position & rotation
					human.position.x += human.dx * humanSpeed * runspeed;
					human.position.y += human.dy * humanSpeed * runspeed;	
					human.rotation.z = Math.atan2(human.dy, human.dx) + Math.PI/2; // TODO: Rotation not working correctly
				}
				
				
				// -------------------------------------------------------------
				// ZOMBIE MOVEMENT
				for(i = 0; i < flock.length; i++){
					zombie = flock[i];
					zombie.duration = 3000;
					align = false;
					alignx = 0;
					aligny = 0;
					ac = 0;
					cohesion = false;
					cohesionx = 0;
					cohesiony = 0;
					cc = 0;
					
					var chase = 1;
					
					for (j = 0; j < people.length; j++){	
						
						var human = people[j];
						
						// ---------------------------------------------
						//TODO: Jämför distance med alla humans
						
						var diffX = zombie.position.x - human.position.x;
						var diffY = zombie.position.y - human.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);
						
						var diffAngle = zombie.rotation.y - human.rotation.z;
						if (diffAngle > Math.PI) diffAngle = 2 * Math.PI - diffAngle;
						if (diffAngle < -Math.PI) diffAngle = -2 * Math.PI + diffAngle;
			
						var seen = Math.abs(diffAngle) <= fov;
	
						// Chase if spotted
						if (distance <= 400){
							if(!seen) continue;
							cohesionx += human.position.x;
							cohesiony += human.position.y;
							cohesion = true;
							cc += 1;
							zombie.duration = 500;
						}		
					}
					
					for (k = 0; k < flock.length; k++){	
						if(i == k) continue;

						var otherZombie = flock[k];
						
						// ----------------------------------------------------------
						// 
						
						var diffX = zombie.position.x - otherZombie.position.x;
						var diffY = zombie.position.y - otherZombie.position.y;
						var distance = Math.sqrt(diffX * diffX + diffY * diffY);
						
						var diffAngle = zombie.rotation.y - otherZombie.rotation.y;
						if (diffAngle > Math.PI) diffAngle = 2 * Math.PI - diffAngle;
						if (diffAngle < -Math.PI) diffAngle = -2 * Math.PI + diffAngle;
			
						var seen = Math.abs(diffAngle) <= fov;
	
						
						// Separate
						if (distance <= 25){
							zombie.dx = zombie.dx * 0.8 + diffX / distance * 0.2;
							zombie.dy = zombie.dy * 0.8 + diffY / distance * 0.2; 
						}
						// Align speed
						else if (distance <= 50){
							if(!seen) continue;
							alignx += otherZombie.dx;
							aligny += otherZombie.dy;
							align = true;
							ac += 1;
						}
						// Cohesion
						else if (distance <= 90){
							if(!seen) continue;
							continue; 								// TODO: Ska de grupperas på avstånd? 
							cohesionx += otherZombie.position.x;
							cohesiony += otherZombie.position.y;
							cohesion = true;
							cc += 1;
						}
						
						// ---------------------------------------------			
					}
					
					if(align){
						avgdx = alignx / ac;
						avgdy = aligny / ac;
						dist = Math.sqrt(avgdx*avgdx + avgdy*avgdy);
						
						zombie.dx = zombie.dx * 0.98 + avgdx / dist * 0.02;
						zombie.dy = zombie.dy * 0.98 + avgdy / dist * 0.02;	

						// Normalize
						dxdyLen = Math.sqrt(zombie.dx*zombie.dx + zombie.dy*zombie.dy);
						zombie.dx /= dxdyLen;
						zombie.dy /= dxdyLen;
					}
					
					if(cohesion){
						// Center coordinates of the crowd
						cohesionx = cohesionx / cc;
						cohesiony = cohesiony / cc;
						
						// Vector towards the center
						avgdx = cohesionx - zombie.position.x;
						avgdy = cohesiony - zombie.position.y;		
						dist = Math.sqrt(avgdx * avgdx + avgdy * avgdy);
						
						zombie.dx = zombie.dx * 0.9 + avgdx / dist * 0.1;
						zombie.dy = zombie.dy * 0.9 + avgdy / dist * 0.1;	
						
						// Normalize
						dxdyLen = Math.sqrt(zombie.dx*zombie.dx + zombie.dy*zombie.dy);
						zombie.dx /= dxdyLen;
						zombie.dy /= dxdyLen;
						
						chase = 10.0;

					}
					
					// Normalize to Length = 1
					var len = Math.sqrt(human.dx*human.dx + human.dy*human.dy);
					zombie.dx /= len;
					zombie.dy /= len;
					
					// ---------------------------------------------
					// Update position on zombie
					if ((zombie.position.x + zombie.dx) < -planeWidth/2) zombie.dx = -zombie.dx;
					if ((zombie.position.y + zombie.dy) < -planeHeight/2) zombie.dy = -zombie.dy;
					if ((zombie.position.x + zombie.dx) > planeWidth/2) zombie.dx = -zombie.dx;
					if ((zombie.position.y + zombie.dy) > planeHeight/2) zombie.dy = -zombie.dy;
					
					zombie.position.x += zombie.dx * zombieSpeed * chase;
					zombie.position.y += zombie.dy * zombieSpeed * chase;	
					zombie.rotation.y = Math.atan2(zombie.dy, zombie.dx) + Math.PI;
					
				}
				
			}
			
			function addZombies(){
				spawnZombie();
				$("#msg").html(flock.length + " zombies");
				$("#info").stop(true).slideDown(300).delay(400).fadeOut(300);
			}
			function addHumans(){
				spawnHuman();
				$("#msg").html(people.length + " humans");
				$("#info").stop(true).slideDown(300).delay(400).fadeOut(300);
			}
			
			// TODO: Tar bort från listan, men inte grafiskt. 
			function removeZombies(){
				if(flock.length > 1){
					scene.remove(flock[0]);
					flock.splice(0,1);
					$("#msg").html(flock.length + " zombies");
					$("#info").stop(true).slideDown(300).delay(400).fadeOut(300);
				}
			}
			function removeHumans(){
				if(people.length > 1){			
					scene.remove(people[0]);
					people.splice(0,1);
					$("#msg").html(people.length + " humans");
					$("#info").stop(true).slideDown(300).delay(400).fadeOut(300);
				}
			}
			
		</script>
		
		<div id="controls">
			<p>
				<button class="addbtn btn btn-success" onclick="addZombies()">
					<span class="glyphicon glyphicon-plus"></span> 
				</button>
				<button class="addbtn btn btn-danger" onclick="removeZombies()">
					<span class="glyphicon glyphicon-minus"></span> 
				</button>
				<span class="label label-danger" id="zlbl">Zombie</span>
			</p>
			
			<p>
				<button class="addbtn btn btn-success" onclick="addHumans()">
					<span class="glyphicon glyphicon-plus"></span> 
				</button>
				<button class="addbtn btn btn-danger" onclick="removeHumans()">
					<span class="glyphicon glyphicon-minus"></span> 
				</button>
				<span class="label label-warning" id="hlbl">Human</span>
			</p>
		</div> <!-- Controls -->
		
		<div id="info" class="messages">
			<div class="alert alert-warning alert-dismissable">
				<strong id="msg">Warning!</strong>
			</div>
		</div>
		<div id="dead"class="messages">
			<div class="alert alert-danger alert-dismissable">
				<strong id="deadmsg">#rekt scrub</strong>
			</div>
		</div>
		
	</body>
</html>